#Суть задачи та же, что и Caesar cipher, с одним отличием: кодируются символы из интервала 1F600—1F64F таблицы символов Юникода. Используется кодировка UTF-8.
#Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита применить единичный сдвиг, то он заменится на первый символ, и наоборот.
#Напишите программу, которая шифрует текст шифром Цезаря.
#Формат ввода:
#На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования.
#Не обращайте внимания, если у вас отображаются прямоугольники вместо некоторых символов. Это значит, что ваш шрифт не содержит этих символов. Для решения задачи это не имеет никакого значения.
#Формат вывода:
#Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри кавычек записана зашифрованная последовательность.

shift, data, abc = int(input()), list(input().strip()), ''.join([chr(i) for i in range(int(0x1f600), int(0x1f64f)+1)])
print("Result: ", end='"')
for c in data:
    print(abc[(abc.index(c) + shift) % len(abc)], end="")
print('"')

#с форума
# Решение даже проще, чем в чистом Цезаре, ведь у нас нет необходимости в строке-алфавите.
# Зачем-то в условии приплели "Используется кодировка UTF-8." Ну я и стал копать в сторону text.encode('utf8'), text.decode('utf8'), получая объект типа bytes, с которым вообще мало чего можно сделать. А сделать там нужно то же самое - прибавить сдвиг и конвертнуть обратно. Как это сделать - не догадался и полез в комменты за командами chr и ord.
# upset, string = int(input()), input()
# print('Result: "', *[chr(128512 + (ord(i) - 128512 + upset) % 80) for i in string], '"', end = '', sep = '')

#-----------------------------
#b, e = 0x1F600, 0x1F64F
#l = e - b + 1
#o = int(input())
#print('Result: "%s"' % (''.join(chr(b + (ord(c) - b + o) % l) for c in input().strip())))

#-----------------------------
#n,s=int(input()),input()
#print('Result: "%s"'%''.join([chr((ord(c)+n-0x1f600)%0x50+0x1f600) for c in s]))

